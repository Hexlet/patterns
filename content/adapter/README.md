# Adapter (Адаптер)

Адаптер — приспособление, устройство или деталь, предназначенные для соединения устройств, не имеющих непосредственного способа соединения.

Адаптерами, вероятно, пользуются практически все люди на планете имеющие доступ к технике. Например посещение разных стран сопряжено с использованием адаптера для сетевых розеток, так как у всех свои разъемы. Существуют даже универсальные адаптеры, позволяющие соединять любой штекер с любой розеткой.

### Проблематика

Паттерн адаптер проявляется в двух ситуациях. Первая связана с возможностью полиморфно работать с разными компонентами, вторая с соединением двух частей программы, которые напрямую работать не могут.

#### 1. Конвертация

Эта проблема один в один совпадает с проблемой, которую решают адаптеры в реальном мире. Она возникает тогда, когда источник данных и потребитель не совместимы по форматам. Например, библиотека для рисования графиков хочет получить данные в виде словаря определенной структуры, а данные для этого графика достаются из базы в виде массива. Или эта же библиотека хочет работать с `json`, а данные для нее хранятся в виде `xml`.

#### Решение

Для решения описанной проблемы, достаточно написать функцию, которая принимает данные из источника и конвертирует их в структуру, подходящую для приемника.

#### 2. Полиморфизм подтипов

Классический пример - базы данных. Их существует довольно много и под каждую базу реализована собственная библиотека (для каджого языка своя и возможно не одна) для взаимодействия с ней. В такой ситуации становится крайне проблематично писать код, взаимодействующий с базой, без учета специфики базы. В этом коде придется зашивать конкретные библиотеки для каждой из поддерживаемых баз данных и повсеместно ставить условные конструкции, которые вызывают те или иные библиотечные функции для взаимодействия с определенной базой данных. К подобным библиотекам (и даже фреймворкам) относятся, например, ORM.

Добавить новую базу данных или использовать другую библиотеку для работы с базой в таком коде невероятно затруднительно. Придется переписывать все места, в которых происходит обращение к базе данных.

```javascript
// node-postgres

import { Client } from 'pg';
const client = new Client({
  user: 'dbuser',
  host: 'database.server.com',
  database: 'mydb',
  password: 'secretpassword',
});

await client.connect();

const res = await client.query('SELECT $1::text as message', ['Hello world!']);
console.log(res.rows[0].message); // Hello world!
await client.end();
```

```javascript
// mysql

import mysql from 'mysql';
const client = mysql.createConnection({
  user: 'dbuser',
  host: 'database.server.com',
  database: 'mydb',
  password: 'secretpassword',
});

client.connect();

client.query('SELECT 1 + 1 AS solution', (error, results, fields) => {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});

connection.end();
```

Несмотря на некоторую схожесть, клиенты для Mysql и Postgresql работают по разному, а значит полиморфное использование невозможно.

Приведу в пример несколько других ситуаций, в которых возникает та же самая проблема:

* Сервисы агрегаторы подобные https://www.skyscanner.ru/ производят поиск билетов по множеству агентств. Каждое агентство имеет свое собственное API. Если реализовывать обращение с ним в лоб, то фактически придется зашивать в код обращение к каждому API независимо. Что опять же приведет к постоянным условным конструкциям и жесткой завязке на конкретные библиотеки для обращения к соответствующим API.
* Конфигурация во фреймворках (различные настройки, например параметры для соединения с базой данных), как правило, может храниться в разных форматах, таких как `xml`, `yaml` или `json`, но на уровне кода она доступна из единого места. Кроме того, конкретный фреймворк может добавлять свои правила поверх форматов, расширяющие возможности конфигурации. К таким возможностям, например, относится наследование конфигураций. Поддержка разных форматов и загрузка конфигурации в систему, как раз, та самая часть, где появляются условные конструкции и зашиваются поддерживаемые форматы и конкретные библиотеки по работе с ними.

### Решение

Решение сводится к написанию обертки под каждую используемую библиотеку таким образом, чтобы все обертки имели общий интерфейс (а по сути тип). Применительно к базам данных, такую абстракцию называют DAL (Data Abstraction Level). Пример использования:

```javascript
import dal from 'dal';
// Выбор подходящего адаптера производится внутри клиента на основании переданного названия базы данных
const client = dal('postgres://user:pass@localhost:5432/dbname');

// Соединение выполняет адаптер конкретной базы
await client.connect();

const res = await client.query('SELECT * FROM USERS ORDER BY id DESC LIMIT 1');
console.log(res[0].message);

await client.end();
```

В коде выше подразумевается, что функция `dal` внутри себя производит выбор нужного адаптера, конфигугирует его и возвращает наружу, другими словами, клиент работает с адаптером напрямую. Это всего лишь один из возможных способов реализации. Существование адаптера может быть скрыто:

```javascript
import Client from 'dal';
// Выбор подходящего адаптера производится внутри клиента на основании переданного названия базы данных
const client = new Client('postgres://user:pass@localhost:5432/dbname');
```

Кроме того, никто не запрещает работать с адаптером напрямую:

```javascript
import { pgAdapter } from 'dal';
// Выбор подходящего адаптера производится внутри клиента на основании переданного названия базы данных
const client = new pgAdapter('user:pass@localhost:5432/dbname');
```

В этом коде всегда создается клиент, который, в свою очередь, содержит адаптер внутри себя и не выдает его наружу. Все запросы к адаптеру идут через клиент. Теперь прикладному коду, который использует соединение с базой данных через `client`, не нужно заботиться о том, какие библиотеки и базы данных нужно поддерживать. Единственно о чем он теперь знает - интерфейс адаптера.

Адаптер в зависимости от сложности адаптации может быть представлен как классом так и функцией. Пример показанный выше довольно сложный и включает в себя оборачивание не только самого соединения, но также и возвращаемого результата из базы. Но нередки ситуации, когда библиотека представляет из себя простую и даже чистую функцию, а значит достаточно обернуть ее в другую функцию имеющую нужный интерфейс. К таким функциям относятся различные парсеры, например, преобразование разных форматов данных (`json`, `yaml` и так далее) в структуры на соответствующем языке.

Адаптерам свойственны те же минусы, что и любой другой абстракции. В попытке обобщить разные виды систем, можно прийти к созданию таких адаптеров, которыми невозможно пользоваться из-за сложности конфигурации и вызовов. К тому же, они будут тем сильнее ограничивать возможности, чем более разные системы адаптируются. Пример с базами данных хорошо подходит под эту ситуацию. Адаптеры под базы данных работают достаточно хорошо, только если эти базы одного типа, например, реляционные. Попытка реализовать общие адаптеры для реляционных и nosql баз данных, обречены на провал. Слишком мало пересечений и слишком много нюансов. Хотя для специализированных случаев, например, кешей, подобная схема может сработать.

### Влияние

`+` Возможность использовать другую библиотеку (функциональность) без необходимости переписывать клиентский код.

`+` Повышает модульность. Клиентский код не завязан на конкретные библиотеки.

`-` Теряется возможность использовать специфику. Чем больше различных систем (с разными возможностями) обобщают адаптеры, тем меньше вариативность поведения. Адаптеры позволяют использовать только пересекающуюся функциональность.

`-` Усложняется анализ. Абстракции всегда текут, вам все равно придется понимать, как работает то, что скрыто за адаптером.

### Когда использовать

* Когда нужна возможность прозрачно подменять используемую систему или библиотеку.

### Реализации

* javascript
    * [Функции](javascript/function)
    * [Класс](javascript/class)
